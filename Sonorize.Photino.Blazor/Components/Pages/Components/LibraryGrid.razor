@using Sonorize.Core
@using Sonorize.Core.Models
@using Sonorize.Core.Settings
@using System.Globalization
@using Microsoft.JSInterop
@inject SonorizeSettings AppSettings
@inject IJSRuntime JS
@implements IAsyncDisposable

<!-- Added overflow-anchor: none to the grid container specifically as well -->
<div @ref="_container"
     class="library-grid-container"
     style="--grid-min-width: @(AppSettings.Library.GridItemWidth)px; --grid-gap: @(AppSettings.Library.GridGap)px; --card-padding: @(AppSettings.Library.GridItemPadding)px; overflow-anchor: none;">

    @if (Songs.Count == 0)
    {
        <div class="empty-message">No songs found.</div>
    }
    else if (Songs.Count <= 250)
    {
        /* --- STANDARD RENDERING (Small Library) --- */
        /* Renders everything immediately. Zero scroll lag, zero pop-in. */
        <div class="standard-grid-layout">
            @foreach (var song in Songs)
            {
                <div class="library-grid-item" @onclick="() => OnSongClick.InvokeAsync(song)">
                    <div class="art-wrapper">
                        @if (song.HasArt)
                        {
                            <img src="@GetArtUrl(song)" loading="lazy" />
                        }
                        else
                        {
                            <div class="art-placeholder"><i class="fas fa-music"></i></div>
                        }
                    </div>
                    <p class="item-title" title="@song.Title">@song.Title</p>
                    <p class="item-subtitle" title="@song.Artist">@song.Artist</p>
                </div>
            }
        </div>
    }
    else
    {
        /* --- VIRTUALIZED RENDERING (Large Library) --- */
        /* Renders only visible rows. High performance, but slight visual pop-in on fast scroll. */
        <Virtualize Items="_chunkedSongs" Context="row" OverscanCount="6" ItemSize="@_estimatedRowHeight">
            <div class="grid-virtual-row" style="height: @(_estimatedRowHeight.ToString("0.00", CultureInfo.InvariantCulture))px;">
                @foreach (var song in row)
                {
                    <div class="library-grid-item" style="height: 100%;" @onclick="() => OnSongClick.InvokeAsync(song)">
                        <div class="art-wrapper">
                            @if (song.HasArt)
                            {
                                <img src="@GetArtUrl(song)" loading="lazy" />
                            }
                            else
                            {
                                <div class="art-placeholder"><i class="fas fa-music"></i></div>
                            }
                        </div>
                        <p class="item-title" title="@song.Title">@song.Title</p>
                        <p class="item-subtitle" title="@song.Artist">@song.Artist</p>
                    </div>
                }
                @* Fill empty space in the last row to maintain alignment *@
                @for (int i = 0; i < _columns - row.Count; i++)
                {
                    <div class="library-grid-item invisible-spacer"></div>
                }
            </div>
        </Virtualize>
    }
</div>

<style>
    .library-grid-container {
        display: block;
        width: 100%;
        padding-top: 20px;
        padding-bottom: 40px;
    }

    /* Standard Layout (CSS Grid) */
    .standard-grid-layout {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(var(--grid-min-width, 180px), 1fr));
        gap: var(--grid-gap, 24px);
    }

    /* Virtualized Layout (Flex Rows) */
    .grid-virtual-row {
        display: flex;
        gap: var(--grid-gap, 24px);
        margin-bottom: var(--grid-gap, 24px);
        /* Changed to center to support the requested 'horizontally centered' requirement
               Since we pad the last row with invisible spacers, this keeps the grid perfectly aligned */
        justify-content: center;
        overflow: hidden;
    }

    /* Item Styles */
    /* In Standard mode, the grid handles width. In Virtual mode, we force flex-basis. */
    .standard-grid-layout .library-grid-item {
        width: 100%;
    }

    .grid-virtual-row .library-grid-item {
        flex: 0 0 var(--grid-min-width, 180px);
        width: var(--grid-min-width, 180px);
    }

    .invisible-spacer {
        visibility: hidden;
        pointer-events: none;
    }
</style>

@code {
    [Parameter] public List<Song> Songs { get; set; } = [];
    [Parameter] public EventCallback<Song> OnSongClick { get; set; }

    private ElementReference _container;
    private DotNetObjectReference<LibraryGrid>? _objRef;
    private List<List<Song>> _chunkedSongs = [];
    private int _columns = 4;
    private float _estimatedRowHeight = 250;
    private double _lastKnownWidth = 0;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _objRef = DotNetObjectReference.Create(this);
            try
            {
                await JS.InvokeVoidAsync("observeResize", _container, _objRef);
            }
            catch { /* Ignore JS errors during init/disposal race */ }
        }
    }

    protected override void OnParametersSet()
    {
        // If we haven't received a width yet, we might use a fallback or wait.
        // If we have a width, re-calc.
        if (Songs.Count > 250)
        {
            if (_lastKnownWidth > 0)
            {
                RecalculateLayout(_lastKnownWidth);
            }
            else
            {
                // Fallback initial calculation
                double width = AppSettings.Window.Width;
                if (AppSettings.Window.IsSidebarOpen) width -= AppSettings.Window.SidebarWidth;
                RecalculateLayout(width);
            }
        }
    }

    [JSInvokable]
    public void OnContainerResize(double width)
    {
        if (Math.Abs(_lastKnownWidth - width) > 5) // Debounce small sub-pixel jitters
        {
            _lastKnownWidth = width;
            if (Songs.Count > 250)
            {
                RecalculateLayout(width);
                StateHasChanged();
            }
        }
    }

    private void RecalculateLayout(double containerWidth)
    {
        int itemWidth = AppSettings.Library.GridItemWidth;
        int gap = AppSettings.Library.GridGap;

        // Calculate columns based on actual container width
        // We use Math.Floor to ensure they fit
        _columns = Math.Max(1, (int)Math.Floor((containerWidth + gap) / (itemWidth + gap)));

        float verticalPadding = AppSettings.Library.GridItemPadding * 2;
        float textAreaHeight = 65; // Fixed allowance for 2 lines of text
        _estimatedRowHeight = (float)Math.Ceiling(itemWidth + verticalPadding + textAreaHeight + gap);

        ChunkData();
    }

    private void ChunkData()
    {
        _chunkedSongs = Songs
            .Select((x, i) => new { Index = i, Value = x })
            .GroupBy(x => x.Index / _columns)
            .Select(x => x.Select(v => v.Value).ToList())
            .ToList();
    }

    private string GetArtUrl(Song song)
    {
        return $"sonorize://albumart/?path={Uri.EscapeDataString(song.FilePath)}";
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("unobserveResize", _container);
        }
        catch { }
        _objRef?.Dispose();
    }
}